= Separating Application Tiers

Jmix is a full-stack framework enabling developers to build enterprise applications with user interface in Java. However, it also provides the flexibility to develop applications with separate frontend and backend tiers when required for security or scalability reasons.

This guide explores a sample application which can serve as an example for implementing custom solutions using the Jmix REST API and REST DataStore features.

[NOTE]
====
It's essential to carefully evaluate your project's requirements and constraints before deciding to implement a separated tier architecture, because it comes with trade-offs:

* *Increased Complexity*: Separating tiers requires managing two distinct applications, each with its own deployment, configuration, and maintenance needs. Developers need to work with two codebases, keeping data models and business logic synchronized between frontend and backend.
* *Limited Functionality*: Some features that are seamlessly integrated in a full-stack Jmix application may require additional effort or custom implementation when tiers are separated.
* *Performance Overhead*: Communication between tiers via REST APIs introduces additional network latency compared to direct method calls in a monolithic application.
====

[[requirements]]
== Requirements

To effectively use this guide, you will need the following:

. xref:ROOT:setup.adoc[Setup] the development environment.

. Clone the https://github.com/jmix-framework/jmix-separate-tiers-sample[sample project^]:
+
[source]
----
git clone https://github.com/jmix-framework/jmix-separate-tiers-sample
----

[[application-overview]]
== Application Overview

The sample project described in this guide illustrates how to partition a Jmix application into distinct frontend and backend components utilizing the xref:rest:index.adoc[] and xref:rest-ds:index.adoc[REST DataStore] add-ons. The resulting distributed system mirrors the functionality of the https://github.com/jmix-framework/jmix-onboarding-2[Jmix Onboarding^] project described in xref:tutorial:index.adoc[] and comprises two web applications:

* *Backend Application* houses JPA entities stored in a dedicated database and exposes the data model through the generic REST API. It also includes essential add-ons like xref:data-tools:index.adoc[] and xref:audit:index.adoc[] for comprehensive data management.

* *Frontend Application* contains Data Transfer Objects (DTOs) that mirror the structure of the backend JPA entities. It performs CRUD operations using the REST DataStore, allowing for user interactions while keeping the backend secure.

Both applications run independently and connect to their respective databases. The frontend stores only user settings, while all application data resides in the backend database.

Both applications have a user interface, but the Backend provides only the user management views, Entity Log and Entity Inspector. The Frontend provides the entire user interface for the Onboarding functionality.

NOTE: In a real-world scenario, consider extracting to the frontend only the essential parts of the domain logic and UI that absolutely require separation, while keeping as much functionality as possible in the backend. This will minimize the overall complexity of the system.

== TO BE CONTINUED

[source,java,indent=0]
----
include::example$/backend-app/build.gradle[]
----